<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Improved Importing of Vector Graphics in R</title>
        <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Inconsolata" media="screen, print">
        <link rel="stylesheet" href="css/normalize.css">
        <link rel="stylesheet" href="css/main.css">
<!--begin.rcode configuration, echo = FALSE, message = FALSE, comment = NA
# Setting knitr options
options(prompt = "R> ", continue = "R+ ")
opts_chunk$set(tidy = FALSE, cache = FALSE, prompt = TRUE,
               message = FALSE,
               comment = NA, highlight = FALSE)
#thm = knit_theme$get('print')
#knit_theme$set(thm)
library(gridSVG)
library(grConvert)
end.rcode-->
    </head>
    <body>
        <header>
            <h1>Improved Importing of Vector Graphics in R</h1>
            <p>
              Simon Potter <a href="mailto:simon.potter@auckland.ac.nz"><code>simon.potter@auckland.ac.nz</code></a> and Paul Murrell <a href="mailto:paul@stat.auckland.ac.nz"><code>paul@stat.auckland.ac.nz</code></a>
            </p>
            <p>Department of Statistics, University of Auckland</p>
            <p><!--rinline I(format(Sys.Date(), "%B %e, %Y")) --></p>
            <p class="abstract">
              <strong>Abstract:</strong> The <em>grImport2</em>
              package imports vector images that are stored in
              the <em>SVG</em> image format for inclusion within
              images generated by R. The original <em>grImport</em>
              package performs the same task, but instead using
              PostScript images as its source image format. This
              technical report describes the steps taken to improve
              not only the <em>grImport</em> package, but also follows
              the development of two new packages, <em>grImport2</em>
              and <em>grConvert</em>. The latter, <em>grConvert</em>,
              converts images from popular vector image formats
              (PostScript, PDF and SVG) into valid input formats
              for <em>grImport</em>
              and <em>grImport2</em>. The <em>grImport2</em> package
              is an entirely new package that does not suffer from
              some limitations of the <em>grImport</em> package, whose
              limitations are primarily due to the dependence on the
              PostScript image format.
            </p>
        </header>
        <h2>Introduction</h2>
        <p>
          The aim of this work for the Google Summer of Code was to
          improve upon the <em>grImport</em>
          package <a href="#ref-1">[1]</a> for the R
          Project <a href="#ref-2">[2]</a>. <em>grImport</em> is a
          package for importing PostScript images into R, which are
          intended to be used within plots created with R
          graphics. The original goal was to accurately recreate the
          state flags of the United States of America. The set of
          flags are already hosted online by Toby Dylan Hocking
          (at <a href="http://sugiyama-www.cs.titech.ac.jp/~toby/flags/index.html">http://sugiyama-www.cs.titech.ac.jp/~toby/flags/index.html</a>)
          and serves as a good set of test cases to see
          where <em>grImport</em> needs improvement.
        </p>
        <p>
          One example of a state flag that needs improvement is that
          of Colorado. This is demonstrated in Figure 1 where the
          original flag is shown on the left, and <em>grImport</em>'s
          attempt at importing and rendering the image is shown on the
          right.
        </p>
        <figure>
        <a href="images/Colorado.ps"><img src="images/Colorado-ps-thumb.png" style="padding:50px 0 50px 0;"></a>
        <a href="images/Colorado.pdf"><img src="images/Colorado-grImport-thumb.png"></a>
        <figcaption>The state flag of Colorado. The original image is shown on the left and <em>grImport</em>'s attempt at importing the flag is shown on the right.</figcaption>
        </figure>
        <p>
          What Figure 1 shows us is that <em>grImport</em> is not
          parsing rectangles correctly. More specifically,
          <em>grImport</em> does not understand
          PostScript's <a href="#ref-3">[3]</a> <code>/rectfill</code>
          and <code>/rectstroke</code> operators and consequently it
          cannot draw them. To correct this rather obvious flaw,
          support for these operators were added to the
          <em>grImport</em> package, which now renders many flags
          correctly without any further changes necessary. The
          corrected Colorado state flag is shown below in Figure 2.
        </p>
        <figure>
<!--begin.rcode improvedColorado, echo = FALSE, fig.keep = "none"
library(grImport)
oldwd <- setwd("images")
PostScriptTrace("Colorado.ps")
colorado <- grImport::readPicture("Colorado.ps.xml")
png("colorado-improved.png", width = 300, height = 300)
# Draw page
grImport::grid.picture(colorado, exp = 0)
invisible(dev.off())
pdf("colorado-improved.pdf")
grImport::grid.picture(colorado, exp = 0)
invisible(dev.off())
# Also drawing a flag of Hawaii while we are still using grImport
PostScriptTrace("Hawaii.ps")
hawaii <- grImport::readPicture("Hawaii.ps.xml")
png("hawaii-improved.png", width = 300, height = 300)
# Draw page
grImport::grid.picture(hawaii, exp = 0)
invisible(dev.off())
pdf("hawaii-improved.pdf")
grImport::grid.picture(hawaii, exp = 0)
invisible(dev.off())
detach("package:grImport")
library(grImport2)
setwd(oldwd)
end.rcode-->
        <a href="images/colorado-improved.pdf"><img src="images/colorado-improved.png"></a>
        <figcaption>The state flag of Colorado, as rendered by an improved version of <em>grImport</em>.</figcaption>
        </figure>
        <p>
          Figure 2 shows us that indeed, this simple fix does correct
          the rendering of the state flags of Colorado. In fact, it
          greatly improves the appearance of most state
          flags. However, limitations in both the PostScript image
          format and R graphics mean that it is simply not possible
          for all of the state flags to be imported by
          <em>grImport</em>. An example of this is PostScript's lack
          of support for semi-transparency when painting within in
          graphics objects e.g. a path or a rectangle. Additionally, R
          graphics does not support clipping to paths, only to
          horizontally and vertically aligned rectangles. These are
          fundamental limitations that cannot be worked around
          by <em>grImport</em> and was the primary motivation for the
          development of
          the <em>grImport2</em> <a href="#ref-4">[4]</a> package.
        </p>
        <p>
          To begin with, let us first demonstrate an example where the
          <em>grImport2</em> package illustrates an improvement. This
          is shown in Figure 3 where the flag of Hawaii renders with a
          few errors in <em>grImport</em>.  The key problems
          with <em>grImport</em>'s rendering is that clipping is not
          applied either to the horizontal stripes or the boundaries
          of the Union Jack. The key reason why <em>grImport</em> does
          not perform clipping is because PostScript clips to a path,
          which is not possible with the R graphics engine. However,
          because <em>grImport2</em> can work out the bounding box of
          a clipping path, it can also clip to the bounding box. The
          result is that the flag of Hawaii now renders correctly with
          <em>grImport2</em>, where it could not do so with the
          existing <em>grImport</em> package.
        </p>
        <figure>
<!--begin.rcode hawaiiCompare, echo = FALSE, fig.keep = "none"
oldwd <- setwd("images")
convertPicture("Hawaii.svg", "Hawaii-cairo.svg")
hawaii <- readPicture("Hawaii-cairo.svg")
png("hawaii-grimport2.png", width = 300, height = 300)
# Draw page
grid.picture(hawaii, expansion = 0, ext = "clipbbox")
invisible(dev.off())
pdf("hawaii-grimport2.pdf")
grid.picture(hawaii, expansion = 0, ext = "clipbbox")
invisible(dev.off())
setwd(oldwd)
end.rcode-->
        <a href="images/hawaii-improved.pdf"><img src="images/hawaii-improved.png"></a>
        <a href="images/hawaii-grimport2.pdf"><img src="images/hawaii-grimport2.png"></a>
        <figcaption>The state flag of Hawaii. <em>grImport</em>'s rendering is shown on the left and <em>grImport2</em>'s attempt at importing the flag is shown on the right.</figcaption>
        </figure>
        <p>
          Despite the aforementioned improvements, there are some
          features of images that cannot be rendered in R graphics at
          all. We have already mentioned clipping to a path, but
          another example of this is gradient fills. A state flag that
          uses this feature extensively is the state flag of Kansas,
          where much of the central features of the flag are filled
          using linear gradients. This graphical feature is not
          currently supported by the R graphics engine, but it is
          supported by the <em>gridSVG</em>
          package <a href="#ref-5">[5]</a>. The <em>gridSVG</em>
          package enables us to use features of
          SVG <a href="#ref-6">[6]</a> within R, the key limitations
          being that the image must be a grid <a href="#ref-2">[2]</a>
          plot, and that the resulting image must be an SVG image
          which is generated by <em>gridSVG</em>.
        </p>
        <figure>
<!--begin.rcode kansasCompare, echo = FALSE, fig.keep = "none"
oldwd <- setwd("images")
convertPicture("Kansas.svg", "Kansas-cairo.svg")
kansas <- readPicture("Kansas-cairo.svg")
png("kansas-grimport2.png", width = 300, height = 300, bg = "transparent")
# Draw page
grid.picture(kansas, expansion = 0, ext = "clipbbox")
invisible(dev.off())
pdf("kansas-grimport2.pdf")
grid.picture(kansas, expansion = 0, ext = "clipbbox")
invisible(dev.off())
gridsvg("kansas-gridsvg.svg")
grid.picture(kansas, expansion = 0, ext = "gridSVG")
invisible(dev.off())
system("inkscape -z -e kansas-gridsvg.png -C -w 300 kansas-gridsvg.svg")
setwd(oldwd)
end.rcode-->
        <a href="images/kansas-grimport2.pdf"><img src="images/kansas-grimport2.png"></a>
        <a href="images/kansas-gridsvg.svg"><img src="images/kansas-gridsvg.png"></a>
        <figcaption>The state flag of Kansas. <em>grImport2</em>'s rendering is shown on the left and <em>grImport2</em>'s attempt at importing the flag with <em>gridSVG</em> is shown on the right.</figcaption>
        </figure>
        <p>
          Figure 4 demonstrates that that if we support linear
          gradients, as is the case when we render
          with <em>gridSVG</em>, the state flag of Kansas can render
          correctly.
        </p>
        <p>
          To summarise, while it is possible to further
          improve <em>grImport</em>'s understanding of PostScript,
          further development of <em>grImport</em> is fundamentally
          limited by the features of both PostScript and the R
          graphics engine. These limitations are not present when
          using SVG as a source image format instead of PostScript.
          These are the primary motivations for the development of a
          new package,
          <em>grImport2</em>, rather than further extending
          the <em>grImport</em> package.
        </p>
        <h2>The <em>grImport2</em> and <em>grConvert</em> Packages</h2>
        <h3>Vector Image Formats</h3>
        <p>
          <em>grImport2</em> targets the SVG image format, which
          contains a superset of the functionality of the R graphics
          engine. One of the key advantages of SVG is that it is a
          grammar of XML <a href="#ref-7">[7]</a>, which means that it
          is straightforward to parse with the <em>XML</em>
          package <a href="#ref-8">[8]</a>. For <em>grImport2</em>,
          the use of the SVG format is similar to <em>grImport</em>'s
          use of its custom RGML image format, which is also a grammar
          of XML. SVG and RGML are similar due to the fact that both
          XML grammars attempt to describe how to draw an image. The
          key difference is that <em>grImport2</em> can import the SVG
          image immediately, but <em>grImport</em> must first create
          the RGML description (via <code>PostScriptTrace()</code>),
          which can then be imported. Another key benefit of
          targetting the SVG image format is that we not only have
          complete access to the features of the R graphics engine,
          but also the features of SVG when the <em>gridSVG</em>
          package is used.
        </p>
        <p>
          It may indeed be the case that PDF <a href="#ref-9">[9]</a>
          supports all of the required graphical features, but it
          would still require the PDF images to be parsed in some
          way. It is this parsing step that is trivial with the SVG
          image format (with the <em>XML</em> package) but far more
          difficult with PDF. In order to parse PDF, we would need
          write a fairly large amount of code, especially considering
          most existing PDF libraries do not expose the graphical
          components of a PDF document. They instead choose to provide
          only a high level rendering function. Furthermore, even if
          PDF were even more graphically sophisticated, SVG is
          sufficiently capable of drawing visually identical plots to
          PDF.
        </p>
        <p>
          A complication with SVG is that unlike PostScript and PDF it
          does not require the use of a physical coordinate system
          (e.g. points). This, among other things (such as attribute
          precedence), complicates the process of importing an SVG
          image. However, if we restrict the SVG we support to the SVG
          that is generated by the Cairo graphics
          library <a href="#ref-10">[10]</a>, then we know that the
          SVG images that we import are guaranteed to belong to a
          common coordinate system and other features of the image
          will be flattened, making it easier to parse. In particular,
          this means that <em>grImport2</em> does not need to parse
          all of the SVG image format, only the subset of SVG that
          Cairo generates. Furthermore, because Cairo is is a
          supported graphics renderer for many open source libraries
          that import vector images, we know that it is possible for
          many input formats to be mapped to the Cairo SVG subset of
          SVG.
        </p>
        <h3>The <em>grConvert</em> package</h3>
        <p>
          We have established that the task of importing vector images for
          <em>grImport2</em> is greatly simplified
          when <em>grImport2</em> imports only the subset of SVG that
          the Cairo graphics library draws. Additionally, it is not
          necessary to target one specific image format, instead we
          can leverage existing libraries that already handle the
          specific image
          formats <a href="#ref-11">[11]</a> <a href="#ref-12">[12]</a> <a href="#ref-13">[13]</a>. However, <em>grImport2</em>'s
          responsibility is for <em>importing</em> graphics, not for
          dealing with image formats. The <em>grConvert</em> package
          has been created to create compliant vector images for
          importing with either <em>grImport</em>
          or <em>grImport2</em>.
        </p>
        <p>
          The <em>grConvert</em> package takes advantage of the fact
          that there are several mature, performant, and easy-to-use
          libraries for parsing popular vector image formats. Another
          key advantage of these libraries is that they support
          rendering by the Cairo graphics library. This means that we
          can take any PostScript, PDF, or SVG image and render it to
          any image format that Cairo supports. For the purposes of
          <em>grConvert</em>, it only ever needs to use Cairo to
          render to either PostScript or SVG for <em>grImport</em>
          and <em>grImport2</em> respectively.
        </p>
        <p>
          The interface provided by <em>grConvert</em> is minimal as
          there is only one function of
          note, <code>convertPicture()</code>. This function takes an
          input vector image that is one of the supported formats
          (PostScript, PDF or SVG) and exports either PostScript
          for <em>grImport</em>, or SVG for <em>grImport2</em>.  By
          default the types of images that we import or indeed export
          are inferred by their file extensions to make most
          conversions as simple as possible.
        </p>
        <p>
          To use <code>convertPicture()</code>, consider the cases
          shown in Figure 5 where we convert various input images to
          SVG, and also to PostScript.
        </p>
        <figure>
<!--begin.rcode grConvertExamples, echo = FALSE
# Avoid messages, just show the code and don't bother actually executing
# everything for now. Part of the reason for this is that currently (on
# my laptop) I cannot convert PS -> SVG because of an error either with
# poppler or gs. Aside from that, this code should work.
cat('R> library(grConvert)',
'R> # Convert PS to SVG',
'R> convertPicture("1.ps", "1.svg")',
'R> # PDF to SVG',
'R> convertPicture("2.pdf", "2.svg")',
'R> # SVG to SVG -- flattening',
'R> convertPicture("3.svg", "3-new.svg")',
'R> # Convert an SVG image to PS for grImport',
'R> convertPicture("4.svg", "4.ps")', sep = "\n")
end.rcode-->
        <figcaption>Converting various vector images to formats suitable for consumption by <em>grImport</em> and <em>grImport2</em>.</figcaption>
        </figure>
        <p>
          This simple interface allows us to create supported input
          images for <em>grImport</em> <strong>and</strong>
          <em>grImport2</em>. For <em>grImport</em>, this was a task
          previously left as an exercise to the user, but is now much
          more convenient with the <em>grConvert</em> package. The
          convenience of converting between vector image formats in R
          reduces the time and effort needed to produce valid images
          for <em>grImport</em> or <em>grImport2</em>. Furthermore, in
          the case of
          <em>grImport2</em>, it also guarantees that the SVG produced
          contain the restricted SVG that <em>grImport2</em> targets.
        </p>
        <h3>Importing with <em>grImport2</em></h3>
        <p>
          At this point in the technical report, we have demonstrated
          some of the capabilities of <em>grImport2</em>, but have not
          yet shown how this is performed. There are only two steps
          necessary to draw images with
          <em>grImport2</em>: reading, and drawing. Reading a picture
          is performed using the <code>readPicture()</code>
          function. It expects a filename or remote location that
          points to an image that should be consumed to create
          a <code>Picture</code> object. This <code>Picture</code>
          contains all of the information necessary to reproduce the
          imported image in R. Once the image has been read in
          via <code>readPicture()</code>, we can reproduce the image
          within R. An example of this is shown in Figure 6 where we
          have a flag of New Zealand, which will be converted
          by <em>grConvert</em> into Cairo SVG, and then read into R
          by <em>grImport2</em>.
        </p>
        <figure>
        <a href="images/nzflag-original.svg"><img src="images/nzflag-original.svg" width="300" alt="A flag of New Zealand, sourced from Wikimedia"></a>
<!--begin.rcode loadNZFlag, echo = c(-1, -8)
oldwd <- setwd("images")
# Converting the image
library(grConvert)
convertPicture("nzflag-original.svg", "nzflag-cairo.svg")
# Reading it into R
library(grImport2)
nzflag <- readPicture("nzflag-cairo.svg")
setwd(oldwd)
end.rcode-->
        <figcaption>Importing the flag of New Zealand into R using <em>grImport2</em>.</figcaption>
        </figure>
        <p>
          There are two high-level functions we can use to draw this
          <code>Picture</code> object. We will first
          examine <code>grid.picture()</code>.
          <code>grid.picture()</code> is a function intended for use
          with the grid graphics system. It takes
          a <code>Picture</code> object, and enables it to be drawn
          within any <em>grid</em> viewport. For example, we can draw
          it to the entire page.
        </p>
        <figure>
<!--begin.rcode drawNZFlag, echo = c(-1, -4:-7), fig.keep = "none"
png("images/nzflag-ex1.png", width = 300, height = 300)
# 'expansion' is 0 so that we take up the entire page
grid.picture(nzflag, expansion = 0)
invisible(dev.off())
pdf("images/nzflag-ex1.pdf")
grid.picture(nzflag, expansion = 0)
invisible(dev.off())
end.rcode-->
        <a href="images/nzflag-ex1.pdf"><img src="images/nzflag-ex1.png" width="300" height="300"></a>
        <figcaption>Drawing an imported image with <em>grImport2</em>.</figcaption>
        </figure>
        <p>
          One problem that we can observe from the rendered image in
          Figure 7 is that the lines in the Union Jack are not clipped
          at all. To correct this problem, <em>grImport2</em> can clip
          to the bounding box of any clipping paths in the image. This
          is demonstrated in Figure 8.
        </p>
        <figure>
<!--begin.rcode drawNZFlagWithBbox, echo = c(-1, -4:-7), fig.keep = "none"
png("images/nzflag-ex-bbox.png", width = 300, height = 300)
# Ensure we clip to the bounding box
grid.picture(nzflag, expansion = 0, ext = "clipbbox")
invisible(dev.off())
pdf("images/nzflag-ex-bbox.pdf")
grid.picture(nzflag, expansion = 0, ext = "clipbbox")
invisible(dev.off())
end.rcode-->
        <a href="images/nzflag-ex-bbox.pdf"><img src="images/nzflag-ex-bbox.png" width="300" height="300"></a>
        <figcaption>Drawing an imported image with <em>grImport2</em> with simple clipping.</figcaption>
        </figure>
        <p>
          By clipping to the bounding box of any clipping paths, at
          least for this simple image, greatly improves the appearance
          of the flag. The rendering is not yet perfect, because the
          diagonal lines in the Union Jack are not clipped
          properly. However, we have reached the limitations of R
          graphics as it does not support this feature. We can
          leverage the <em>gridSVG</em> package to clip to these paths
          when it exports an SVG image. This is illustrated in Figure
          9.
        </p>
        <figure>
<!--begin.rcode drawNZFlagWithPathClip, echo = FALSE, cache = FALSE, fig.keep = "none"
gridsvg("images/nzflag-with-complex-clipping.svg",
        width = 300 / 72, height = 300 / 72, res = 72)
grid.picture(nzflag, expansion = 0, ext = "gridSVG")
invisible(dev.off())
gridSVG.newpage()
cat('R> # Ensure we clip using clipping *paths*',
    'R> grid.picture(nzflag, expansion = 0, ext = "gridSVG")',
    'R> grid.export("nzflag-with-complex-clipping.svg")',
    sep = "\n")
end.rcode-->
        <a href="images/nzflag-with-complex-clipping.svg"><img src="images/nzflag-with-complex-clipping.svg" width="300" height="300"></a>
        <figcaption>Drawing an imported image with <em>grImport2</em> with complex clipping.</figcaption>
        </figure>
        <p>
          The use of clipping paths instead of clipping rectangles
          improves the appearance of our flag so that it now renders
          identically to the source image.
        </p>
        <p>
          We have focused on clipping, but there are further graphical
          features that we can use. For example, the central features
          of the state flag of Kansas contains linear gradients. These
          are not shown at all without the use of <em>gridSVG</em>,
          instead they are drawn using the current fill colour. This
          means that the use of <em>gridSVG</em> is beneficial, and in
          cases like these, essential for accurate reproduction of
          imported graphics.
        </p>
        <figure>
<!--begin.rcode drawKansasWithGridSVGFeatures, echo = FALSE, fig.keep = "none"
oldwd <- setwd("images")
gridSVG.newpage()
pdf(file = NULL, width = 300 / 72, height = 300 / 72)
convertPicture("Kansas.svg", "Kansas-cairo.svg")
kansas <- readPicture("Kansas-cairo.svg")
# Use gridSVG features *and* gridSVG clipping
grid.picture(kansas, expansion = 0, ext = "gridSVG")
grid.export("imported-kansas.svg", res = 72)
invisible(dev.off())
setwd(oldwd)
gridSVG.newpage()
cat('R> convertPicture("kansas.svg", "kansas-cairo.svg")',
    'R> kansas <- readPicture("kansas-cairo.svg")',
    'R> # Use gridSVG features *and* gridSVG clipping',
    'R> grid.picture(kansas, expansion = 0, ext = "gridSVG")',
    'R> grid.export("imported-kansas.svg")',
    sep = "\n")
end.rcode-->
        <a href="images/imported-kansas.svg"><img src="images/imported-kansas.svg" width="300" height="300"></a>
        <figcaption>Drawing an imported image with <em>grImport2</em> with complex clipping and using SVG features with <em>gridSVG</em>.</figcaption>
        </figure>
        <h3>Custom Plotting Characters</h3>
        <p>
          The second high level function that <em>grImport2</em>
          provides for working with <code>Picture</code> objects is
          called <code>grid.symbols()</code>.  It is used for drawing
          several copies of of a picture at a set of
          (<code>x</code>, <code>y</code>) locations, with specified
          sizes.  For statistical graphics purposes, the most obvious
          use for this function is to create custom plotting
          characters.
        </p>
        <p>
          To demonstrate how this may be used, we will use a custom
          panel function for the <em>lattice</em> package. The panel
          function will give us some (<code>x</code>, <code>y</code>)
          locations to plot at and will also give a random size for
          each of the pieces of the plot.
        </p>
        <figure>
<!--begin.rcode symbolsExample, echo = c(-1, -7:-10), fig.keep = "none"
png("images/nzflag-as-symbol.png", width = 300, height = 300)
customPanel <- function(x, y, ...) {
    # Sizing the flags randomly for demonstration purposes
    sizes <- runif(length(x), min = 5, max = 10)
    grid.symbols(nzflag,
                 x = x, y = y,
                 default.units = "native",
                 size = unit(sizes, "mm"),
                 ext = "clipbbox")
}
library(lattice)
xs <- rnorm(10, mean = 30, sd = 10)
ys <- rnorm(10, mean = 70, sd = 20)
xyplot(ys ~ xs, panel = customPanel)
invisible(dev.off())
pdf("images/nzflag-as-symbol.pdf")
xyplot(ys ~ xs, panel = customPanel)
invisible(dev.off())
end.rcode-->
        <a href="images/nzflag-as-symbol.pdf"><img src="images/nzflag-as-symbol.png" width="300" height="300"></a>
        <figcaption>Using an imported image to represent data points in a <em>lattice</em> plot.</figcaption>
        </figure>
        <p>
          Figure 11 shows that we have an easy way of using custom
          data symbols in <em>grid</em> plots if we
          use <code>grid.symbols()</code> instead of the
          familiar <code>grid.points()</code> function. One drawback
          however is that <code>grid.symbols()</code> can only draw
          one
          <code>Picture</code> object repeatedly. To draw multiple
          custom symbols will require multiple calls
          to <code>grid.symbols()</code>.
        </p>
        <h2>Customisation</h2>
        <p>
          One of the things you may want to do is change the
          appearance of a picture once it has been imported. There are
          two ways to do this, but we will first discuss the most
          convenient method; the second will be discussed later in
          this technical report.
        </p>
        <p>
          The most convenient way to modify images imported
          by <em>grImport2</em> is to change their graphical
          parameters, for example the colours that are being used
          within a flag. Both the <code>grid.picture()</code> and
          <code>grid.symbols()</code> functions have an optional
          argument called
          <code>gpFUN</code>. This argument should be a function that
          takes a <em>grid</em> <code>gpar</code> object, and returns
          a modified version of that object. This is a much simpler
          approach than writing custom methods
          for <code>Picture</code> and related objects (as is the case
          with <em>grImport</em>). Primarily this is because the task
          of creating graphics <em>objects</em> should be undertaken
          by <em>grImport2</em>, but changing the
          graphical <em>parameters</em> of pictures should be
          configurable by the user.
        </p>
        <p>
          As we have established earlier, the way in which the
          graphical parameters can be modified is by the use of a
          function that takes a <code>gpar</code> object and returns a
          modified <code>gpar</code> object. We will construct a
          function that desaturates all of the colours in
          a <code>gpar</code> object, and apply that to our flag of
          New Zealand.
        </p>
        <figure>
<!--begin.rcode usegpFUN, echo = c(-1:-2, -6:-9), fig.keep = "none"
png("images/gpfun-example.png", width = 300, height = 300)
library(colorspace) # for desaturate()
# Create a gpar desaturation function
gpDesaturate <- function(x) {
    if ("col" %in% names(x))
        x$col <- desaturate(x$col)
    if ("fill" %in% names(x))
        x$fill <- desaturate(x$fill)
    x
}
grid.picture(nzflag, expansion = 0, ext = "clipbbox",
             gpFUN = gpDesaturate)
invisible(dev.off())
pdf("images/gpfun-example.pdf")
grid.picture(nzflag, expansion = 0, ext = "clipbbox",
             gpFUN = gpDesaturate)
invisible(dev.off())
end.rcode-->
        <a href="images/gpfun-example.pdf"><img src="images/gpfun-example.png" width="300" height="300"></a>
        <figcaption>Modifying the flag of New Zealand by modifying graphical parameters.</figcaption>
        </figure>
        <p>
          Figure 12 shows how the <code>gpFUN</code> argument can be
          used to modify the appearance of an imported image. The flag
          of New Zealand now appears in greyscale colours. Not only is
          it possible to change the colours of an image, but it is
          also possible to manipulate the image by showing only the
          strokes in the image.
        </p>
        <h2>A Complex Example</h2>
        <p>
          Many of the examples used so far appear relatively simple,
          perhaps with the exception of the state flag of Kansas
          (Figures 4 and 10).  However, because the software libraries
          that <em>grConvert</em> relies upon are sufficiently mature,
          the input images for <em>grImport2</em> can be equally as
          sophisticated as the images from which they were sourced.
          For example, a type of picture that typically contains a lot
          of content are pages in most PDF documents. We will
          demonstrate that <em>grImport2</em> can render complex
          pictures using using a page from the <em>grImport</em>
          article published in the Journal of Statistical
          Software <a href="#ref-14">[14]</a>. Figure 13 also
          illustrates the use of the <code>pagenum</code> argument
          in <code>convertPicture()</code>. <code>pagenum</code>
          selects the page that will be converted from the source
          document to PostScript or SVG.
        </p>
        <figure>
<!--begin.rcode complexExample, echo = c(2:5, 7:8), fig.keep = "none"
oldwd <- setwd("images")
# Convert page 2 to SVG for grImport2
convertPicture("grimport-jss.pdf", "complex.svg", pagenum = 2)
# Read in the page
page <- readPicture("complex.svg")
png("complex-example.png", width = 300, height = 300)
# Draw page
grid.picture(page, expansion = 0)
invisible(dev.off())
pdf("complex-example.pdf")
grid.picture(page, expansion = 0)
invisible(dev.off())
setwd(oldwd)
end.rcode-->
        <a href="images/complex-example.pdf"><img src="images/complex-example.png" width="300" height="300"></a>
        <figcaption>Displaying a page that has been imported from a PDF document. A PDF version of this figure can be viewed by clicking on the PNG image.</figcaption>
        </figure>
        <p>
          When rendering to the PDF graphics device, one can zoom in
          and observe that the image produced by <em>grImport2</em> is
          imperceptibly different to the original page in the PDF
          document. The main reason why the content of the page is
          reproduced with a high degree of accuracy is because the
          Cairo graphics library translates text into an equivalent
          representation using SVG paths. A consequence of this
          translation is that <em>grImport2</em> cannot import text as
          text, instead only the shapes are imported.
        </p>
        <h2>The Merits of <em>grImport</em> vs <em>grImport2</em></h2>
        <p>
          Much of the content of this technical report has discussed
          the motivation and the benefits to using <em>grImport2</em>,
          but this does not necessarily mean that <em>grImport</em>
          should be discarded. There are features
          that <em>grImport</em> has that <em>grImport2</em>
          lacks. One of these features is the ability to import text
          as text. This means that it is possible to import a
          PostScript image containing text, then modify not only the
          text itself, but also its appearance (e.g. by changing its
          font). <em>grImport2</em> can only import text as a
          path. This approach is problematic because paths are more
          difficult to modify and therefore generally support
          modification only to their graphical parameters.
        </p>
        <p>
          Another advantage to <em>grImport</em> is that the R objects
          it creates to represent the imported image are far simpler,
          being comprised only of paths. This means that it is far
          simpler to modify an image if we know how to modify a path,
          rather than dealing with the multitude of groups and other
          types of objects that <em>grImport2</em> creates. To
          demonstrate this, first consider the simple subset operation
          to show only a specific set of content in Figure 14.
        </p>
        <figure>
<!--begin.rcode page27grImportExample, echo = 4:8, fig.keep = "none"
oldwd <- setwd("images")
detach("package:grImport2") ; library(grImport)
png("page27.png", width = 300, height = 300)
PostScriptTrace("page27.ps")
page27 <- readPicture("page27.ps.xml")
survivalPlot <- page27[c(3:16, 18, 27)]
# Show survival plot
grid.picture(survivalPlot)
invisible(dev.off())
pdf("page27.pdf")
# Show survival plot
grid.picture(survivalPlot)
invisible(dev.off())
detach("package:grImport") ; library(grImport2)
setwd(oldwd)
end.rcode-->
        <a href="images/page27.pdf"><img src="images/page27.png" width="300" height="300"></a>
        <figcaption>A survival plot, originally taken from an R News article, which is modified using code from the JSS article on <em>grImport</em>.</figcaption>
        </figure>
        <p>
          The subsetting operation shown in Figure 14 was simply
          reducing the image to only show paths 3&mdash;16, 18 and
          27. Because everything drawn in <em>grImport</em> is a path,
          and the imported picture is simply a series of path drawing
          operations, the subsetting operation is simply keeping only
          some of the paths.
        </p>
        <p>
          Performing similar manipulations of an imported picture
          using <em>grImport2</em> is more complicated
          process. Firstly, as is the case with <em>grImport</em> we
          do not have any convenient way of knowing, for example,
          which paths in the flag of New Zealand represent the stars
          or the Union Jack. A second complication is that there is
          some structure to the <code>Picture</code> object that
          closely matches that of the source Cairo SVG image. This
          means that there are often trees of graphical content
          represented in <code>Picture</code>
          objects. <em>grImport</em> does not suffer from this
          complication as it manages a series of drawing operations,
          rather than any trees of graphical content.
        </p>
        <p>
          Despite these complications, and after some trial and error,
          we can subset or add content to
          a <em>grImport2</em> <code>Picture</code> object. Figure 15
          shows an example where the Union Jack on the flag of New
          Zealand is removed using subsetting operations on
          a <code>PictureGroup</code> object.
        </p>
        <figure>
<!--begin.rcode grImport2Subset, echo = c(-1, -8:-11), fig.keep = "none"
png("images/nzstars.png", width = 300, height = 300)
# Create a copy
nzstars <- nzflag
# Remove pieces that represent the Union Jack
# (children 3-8 of the main group)
nzstars@content[[1]]@content <- nzflag@content[[1]]@content[-3:-8]
grid.picture(nzstars, expansion = 0)
invisible(dev.off())
pdf("images/nzstars.pdf")
grid.picture(nzstars, expansion = 0)
invisible(dev.off())
end.rcode-->
        <a href="images/nzstars.pdf"><img src="images/nzstars.png" width="300" height="300"></a>
        <figcaption>Modifying the flag of New Zealand by removing the Union Jack using subset operations.</figcaption>
        </figure>
        <p>
          In general when modifying <code>Picture</code> objects, it
          may be useful to know that they closely match the structure
          of the SVG image that they were sourced from. For example,
          when modifying the flag in Figure 15, we knew that the image
          was composed of a single
          <code>PictureGroup</code> object, which contains many
          children. With this information at hand, it is reasonably
          simple (albeit trial and error) to work out which children
          of the <code>PictureGroup</code> are responsible for drawing
          the Union Jack. However, it is clear that <em>grImport</em>
          does make this type of task much simpler.
        </p>
        <p>
          Another advantage of <em>grImport</em> is that it should be
          expected to work with any PostScript image,
          whereas <em>grImport2</em> is dependent not only on SVG, but
          the specific subset of SVG that Cairo
          generates. <em>grImport2</em> relies heavily on the
          structure of Cairo's SVG output so any change to Cairo could
          cause <em>grImport2</em> to import the image incorrectly, or
          perhaps fail altogether. This is an important dependency to
          note but the Cairo SVG surface appears to be quite
          stable. It is unlikely to change in such a drastic manner
          that it would invalidate much of the parsing behaviour
          of <em>grImport2</em>.
        </p>
        <p>
          In summary, if the goal is to accurately reproduce images in
          R then <em>grImport2</em> is a more complete
          solution. However, <em>grImport</em> is simpler and
          its <code>Picture</code> objects can be manipulated more
          easily; if that is of greater importance
          then <em>grImport</em> may be a preferable solution. The
          cost of using <em>grImport</em> instead
          of <em>grImport2</em> is that reproduction of images is
          unlikely to be as accurate.
        </p>
        <h2>Conclusion</h2>
        <p>
          We have demonstrated work performed as part of the Google
          Summer of Code for the R Project. This work resulted in
          minor changes to the
          <em>grImport</em> package, often leading to significant
          improvements in rendering. The
          <em>grImport2</em> package was also created in order to work
          around limitations in the PostScript image format, in
          addition to limitations in R graphics. It is able to
          reproduce imported images with high fidelity, and when used
          with the <em>gridSVG</em> package, images can be reproduced
          to a greater degree than what R is capable of drawing.
        </p>
        <p>
          In addition to developing improved tools for importing
          vector graphics, the <em>grConvert</em> package has been
          developed. It provides a convenient R interface for
          converting popular vector image formats into a format
          suitable for use in both <em>grImport</em>
          and <em>grImport2</em>.
        </p>
        <h2>Acknowledgements</h2>
        <p>
          The work demonstrated in this technical report was
          undertaken as part of the the Google Summer of Code
          2013. Google funded the work entirely and without their
          support the development of this software would not have
          occurred.
        </p>
        <p>
          The original versions of the flags shown in this technical
          report are freely available and have been sourced from
          the <a href="http://commons.wikimedia.org/">Wikimedia
          Commons</a>. Thanks for the authors of these flags for
          providing such good examples for test cases.
        </p>
        <h2>Downloads</h2>
        <p>
          This document is licensed under a <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/nz/">Creative Commons Attribution 3.0 New Zealand License</a>.
        </p>
        <img src="images/88x31.png" width="88" height="31" style="margin: 20px auto; display: block;">
        <p>
          The code is freely available under
          the <a href="files/gpl.txt">GPL</a>. The described
          functionality of <em>grConvert</em>, <em>grImport</em> and <em>grImport2</em>
          are present in the latest revisions of the packages on
          <a href="http://r-forge.r-project.org/projects/grimport/">R-Forge</a>.
        </p>
        <ul>
            <li><a href="files/grImport2.Rhtml">Code used to generate this technical report</a> (note, requires <a href="http://yihui.name/knitr/"><em>knitr</em></a>, available on CRAN)</li>
        </ul>
        <p>
          In addition to the sources for the technical report and the
          packages described in the technical report, there is also a
          web page that shows and describes the improvements made to
          the rendering of the state flags of the USA. The web page is
          available
          at: <a href="https://dl.dropboxusercontent.com/u/54315147/import/state-table.html">https://dl.dropboxusercontent.com/u/54315147/import/state-table.html</a>,
          with the source code for generating the web page available
          on GitHub
          at: <a href="https://github.com/sjp/grImport-flag-tests">https://github.com/sjp/grImport-flag-tests</a>.
        </p>
        <h2>References</h2>
        <ol>
            <li id="ref-1">Murrell, P. and Walton, R. (2012). <span class="pkg-desc">grImport: Importing Vector Graphics</span>. <a href="http://r-forge.r-project.org/projects/gridsvg/">http://r-forge.r-project.org/projects/grimport/</a>. R package version 0.8-4.</li>
            <li id="ref-2">R Development Core Team (2013). <span class="pkg-desc">R: A Language and Environment for Statistical Computing</span>. R Foundation for Statistical Computing, Vienna, Austria. ISBN 3-900051-07-0.</li>
            <li id="ref-3">Adobe Systems (1999). <span class="pkg-desc">Postscript Language Reference. 3rd edition</span>. Addison-Wesley. ISBN 9780201379228.</li>
            <li id="ref-4">Potter S. (2013). <span class="pkg-desc">grImport2: Importing Vector Graphics</span>. <a href="http://r-forge.r-project.org/projects/gridsvg/">http://r-forge.r-project.org/projects/grimport/</a>. R package version 0.1-0.</li>
            <li id="ref-5">Murrell, P. and Potter, S. (2013). <span class="pkg-desc">gridSVG: Export grid graphics as SVG</span>. <a href="http://r-forge.r-project.org/projects/gridsvg/">http://r-forge.r-project.org/projects/gridsvg/</a>. R package version 1.3-0.</li>
            <li id="ref-6">W3C (2011). <span class="pkg-desc">Scalable Vector Graphics (SVG) 1.1 (Second Edition) Specification</span>. <a href="http://www.w3.org/TR/SVG/">http://www.w3.org/TR/SVG/</a>.</li>
            <li id="ref-7">W3C (2008). <span class="pkg-desc">Extensible Markup Language (XML) 1.0 (Fifth Edition)</span>. <a href="http://www.w3.org/TR/xml/">http://www.w3.org/TR/xml/</a>.</li>
            <li id="ref-8">Lang, D. T. (2013). <span class="pkg-desc">XML: Tools for parsing and generating XML within R and S-Plus</span>. <a href="http://www.omegahat.org/RSXML/">http://www.omegahat.org/RSXML/</a>. R package version 3.98-1</li>
            <li id="ref-9">Adobe Systems (2006). <span class="pkg-desc">PDF Version 1.7 Reference. 6th edition</span>. <a href="http://www.adobe.com/content/dam/Adobe/en/devnet/acrobat/pdfs/pdf_reference_1-7.pdf">http://www.adobe.com/content/dam/Adobe/en/devnet/acrobat/pdfs/pdf_reference_1-7.pdf</a>.</li>
            <li id="ref-10">Packard, K., Worth, C. and Esfahbod, B. (2013). <span class="pkg-desc">cairo</span>. <a href="http://cairographics.org/">http://cairographics.org/</a>. Version 1.12.14.</li>
            <li id="ref-11">freedesktop.org (2013). <span class="pkg-desc">libspectre</span>. <a href="http://libspectre.freedesktop.org/">http://libspectre.freedesktop.org/</a>. Version 0.2.7.</li>
            <li id="ref-12">freedesktop.org (2013). <span class="pkg-desc">Poppler</span>. <a href="http://poppler.freedesktop.org/">http://poppler.freedesktop.org/</a>. Version 0.22.2.</li>
            <li id="ref-13">GNOME Project. (2013). <span class="pkg-desc">librsvg</span>. <a href="http://live.gnome.org/LibRsvg">http://live.gnome.org/LibRsvg</a>. Version 2.37.</li>
            <li id="ref-14">Murrell, P. (2009). <span class="pkg-desc">Importing Vector Graphics: The grImport Package for R</span>. Journal of Statistical Software, 30(4), 1-37. <a href="http://www.jstatsoft.org/v30/i04/">http://www.jstatsoft.org/v30/i04/</a>.</li>
        </ol>
        <script type="text/javascript" src="js/modernizr.js"></script>
        <script type="text/javascript" src="js/detect.js"></script>
    </body>
</html>
